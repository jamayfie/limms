% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scatterQC.R
\name{scatterQC}
\alias{scatterQC}
\title{Plot mass spectrometry data for quality control}
\usage{
scatterQC(
  peaklistCols,
  seed = NULL,
  groupNames = NULL,
  main = NULL,
  outlayer = FALSE,
  zero = FALSE
)
}
\arguments{
\item{peaklistCols}{An R object of peak data, with peaks in rows and samples in columns.}

\item{seed}{Set a seed to generate the same plot each time the function is used.}

\item{groupNames}{If used, a vector of names for each column with peak data.
To group the samples, enter a vector of group names as long as the column names.
If not used, the names attribute of the input object is used and no groups are plotted.}

\item{main}{The main plot title.}

\item{outlayer}{If a sample is an outlier according to 'check_outlier()', 
setting outlayer=TRUE adds a text label, allowing identification.  
The default is FALSE.}

\item{zero}{Set to zero=TRUE to start the y axis at zero.
The default is FALSE, zooming the y-axis to the data.}
}
\description{
This function makes two plots from a table of mass spectrometry data to assess quality
and to compare sample types.  Data are log transformed: input data should be raw,
untransformed peak data.
}
\details{
The top scatter plot of nonzero ions shows the number of peaks measured above threshold
for each sample, binned by sample class.  
Nonzero ions are counted first to make the top plot, but then are imputed 
using 'imputeZerosUnifMin()' to generate the lower plot.

The bottom boxplot shows the quantiles of the imputed peak intensities.

These plots are useful compared to historical data and to compare the sample classes.
Note: if 'xcms' was used to generate the peaklistCols, 
'fillPeaks()' adds data to zero peaks: avoid using 'fillPeaks()' to get a true nonzero
peak list, but a fair number of zeros will still remain after 'fillPeaks()'.
}
\examples{

require(data.table)
require(ggplot2)
require(cowplot)
require(forcats)

# Extract the data columns from CBS.xcms_diffreport, 
# an xcms diffreport object included as limms package data,
# impute the zeros, and log2 transform (the default in imputeZerosUnifMin).

desMetB6 <- cbind(names(CBS.xcms_diffreport[,24:55]), c(rep("CBS",4), rep("CBS",4), rep("CBS",4), 
rep("CBS",4), rep("CBS",4), rep("CBS",4), rep("G307S",4), rep("G307S",4)), 
c(rep("Yes",4), rep("Yes",4), rep("Yes",4), rep("Yes",4), rep("No",4), rep("No",4),
rep("Yes",4), rep("Yes",4)),  c(rep("High",4), rep("High",4), rep("Low",4), 
rep("Low",4), rep("High",4), rep("Low",4), rep("High",4), rep("Low",4)), c(rep(2,4),
rep(1,4), rep(2,4), rep(1,4), rep(1,4), rep(1,4), rep(2,4), rep(2,4)))
desMetB6 <- data.frame(desMetB6)
names(desMetB6) <- c("Run", "Strain", "Met", "B6", "Rep")

# QC plot of all samples
# this can be useful for checking run order, etc
scatterQC(CBS.xcms_diffreport[, c(24:55)], seed=75, main="QC of all samples")

# QC plot by group
# Treatments are expected to differ... but it's still useful to know which ones!
# flag outlier samples
scatterQC(CBS.xcms_diffreport[, c(24:55)], seed=75, groupNames=desMetB6$Met, 
  main="QC by methionine addition", outlayer=TRUE)

}
\seealso{
\code{\link{dbMatch}}
\code{\link{imputeZerosUnifMin}}
}
